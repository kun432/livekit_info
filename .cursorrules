{
    "version": "2.1",
    "patterns": [
        {
            "name": "Agent Structure",
            "pattern": "class {{AgentName}}(VoiceAgent):",
            "language": "python",
            "message": "Agents should inherit from VoiceAgent and follow the template structure"
        },
        {
            "name": "Required Imports",
            "pattern": "from livekit.agents import (rtc, llm, stt, tts, vad, utils)",
            "message": "Import core components from livekit.agents module"
        },
        {
            "name": "AI Function Decorator",
            "pattern": "@llm.ai_function()\nasync def {{fnc_name}}(ctx: FunctionContext):",
            "message": "Use @llm.ai_function decorator for all AI functions"
        },
        {
            "name": "Entrypoint Function",
            "pattern": "async def run(self):",
            "message": "Implement async run() method as agent entrypoint"
        },
        {
            "name": "Main Block",
            "pattern": "if __name__ == \"__main__\":\n    asyncio.run(main())",
            "message": "Use standard main block with asyncio"
        },
        {
            "name": "Env Vars",
            "pattern": "os.environ.get(\"LIVEKIT_*\")",
            "message": "Access credentials via environment variables"
        },
        {
            "name": "Logging",
            "pattern": "logger = logging.getLogger(__name__)",
            "message": "Use module-level logger instead of print()"
        },
        {
            "name": "VoiceAgent Setup",
            "pattern": "VoiceAgent(\n    stt={{stt_instance}},\n    tts={{tts_instance}},\n    llm={{llm_instance}},\n    vad={{vad_instance}})",
            "message": "Configure required components with explicit instances"
        },
        {
            "name": "Fallback Adapter",
            "pattern": "FallbackAdapter(primary={{service}}, backups=[{{backup_service}}])",
            "message": "Implement fallback strategy for critical services"
        },
        {
            "name": "RoomIO Config",
            "pattern": "RoomIO(\n    room=room,\n    input_options=RoomInputOptions(\n        audio_enabled=True\n    ),\n    output_options=RoomOutputOptions(\n        audio_enabled=True\n    ))",
            "message": "Explicitly configure RoomIO input/output options"
        },
        {
            "name": "STT Streaming",
            "pattern": "async with stt.stream() as stream:",
            "message": "Use context managers for streaming resources"
        },
        {
            "name": "TTS Metrics",
            "pattern": "utils.metrics.record(\"tts_latency\", duration)",
            "message": "Track TTS performance metrics"
        }
    ],
    "recommendations": {
        "voice_agent": [
            "Set max_fnc_steps=3-5 for complex workflows",
            "Enable allow_interruptions for conversational agents",
            "Configure min_endpointing_delay=0.3-0.5s for natural pauses"
        ],
        "error_handling": [
            "Implement retry logic for network operations",
            "Use FallbackAdapter for STT/TTS services",
            "Add timeout decorators to async functions"
        ],
        "performance": [
            "Monitor P90/P95 latency values",
            "Keep context windows under 4K tokens",
            "Use quantization for large LLMs"
        ]
    },
    "migration": {
        "v1_to_v2": [
            "Replace AudioProcessor with RoomIO",
            "Update FunctionContext parameter order",
            "Migrate to new metrics tracking API"
        ]
    },
    "examples": {
        "worker": {
            "pattern": "worker = Worker(\n    agent_factory=create_agent,\n    livekit_url=\"wss://{{host}}\",\n    api_key=os.environ[\"LIVEKIT_API_KEY\"],\n    api_secret=os.environ[\"LIVEKIT_API_SECRET\"])",
            "message": "Configure worker with env vars and factory function"
        },
        "function_call": {
            "pattern": "@llm.ai_function()\nasync def search_products(ctx):\n    \"\"\"Search inventory\"\"\"\n    params = ctx.values\n    return await inventory.search(**params)",
            "message": "Implement AI functions with proper docstrings and typing"
        }
    }
} 